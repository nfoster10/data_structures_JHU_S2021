By the end of this module, students will be able to:

    Categorize and label graphs accurately using basic graph terminology.
    Define an m-ary tree in terms of an underlying graph.
    Restrict an m-ary tree into a rooted tree.
    Build a general tree using a random list of data.
    Apply concepts on Queue and List Structures (Modules 4 and 6) to the discussion.

The prompt questions for this module are:

    What attributes of a problem might you consider when deciding how to represent a graph?
    	graphs show relationships between nodes or verticies so it would be important to determine if these relationsips need to be weighted.
    What are some advantages of using a linked structure to represent a graph?  Disadvantages? 
    	Probably more efficient insertions and less efficient searching
    Why might an array be better (or worse) than a linked structure to represent a graph?
    	The major proble with an array would be size changes to the graph if nodes are constantly changing. A geographic problem, this wouldn't be a huge problem since land masses are not frequently appearing and disappearing. However a social network modedled by a graph may have frequent additions or removal of nodes depending on the person.
    Can you name some applications for which a graph representation might be useful?
    	A computer network would be a good example for using a graph representation. It can show which nodes are able to communicate and help eliminate latencies. In my work, we are installing a firewall and a graph representation is very helpful for understanding the impacts of the firewall.
    What aspects of graphs make them a good (or poor) match for recursive solutions?
    	Graphs are good candidates for recursion as each node can be generally treated the same until every node has been visited. however this does lead to frequent searches and upkeep to confirm whether or not has laready been visited or discovered.

The discussion question is: 

	List Variations - Suggest an implementation for sparse matrices, selecting from non-linked options as well as linked options. Pick something that has not already been selected by another student. Discuss your choice in terms of possible row and column operations on the matrix and consider efficiency issues

		i really don't know!

Graphs:
	node
	vertex
	edge
	directed
	undirected
	parallel 
	connected

list
	rooted
	binary tree
	m-ary tree
	child
	parent
	ancestor
	descendent
	sibling
	degree
	in-degree
	out-degree
adjacency list graph representation is a sive of O(V_E)

determine adjacency is O(V)

a sparse graph has fewer edges than the max possible edges because only adjacent to a few nodes other nodes. real word examples are computer networks, flights between cities



BFS(startV) {
   Enqueue startV in frontierQueue
   Add startV to discoveredSet

   while ( frontierQueue is not empty ) {
      currentV = Dequeue from frontierQueue
      Visit currentV
      for each vertex adjV adjacent to currentV {
         if ( adjV is not in discoveredSet ) {
            Enqueue adjV in frontierQueue
            Add adjV to discoveredSet
         }
      }
   }
}



DFS(startV) {
   Push startV to stack

   while ( stack is not empty ) {
      currentV = Pop stack
      if ( currentV is not in visitedSet ) {
         Visit currentV
         Add currentV to visitedSet
         for each vertex adjV adjacent to currentV
            Push adjV to stack
      }
   }
}

RecursiveDFS(currentV) {
   if ( currentV is not in visitedSet ) {
      Add currentV to visitedSet
      Visit currentV
      for each vertex adjV adjacent to currentV {
         RecursiveDFS(adjV)
      }
   }
}





MaxHeapPercolateUp(nodeIndex, heapArray) {
   while (nodeIndex > 0) {
      parentIndex = (nodeIndex - 1) / 2
      if (heapArray[nodeIndex] <= heapArray[parentIndex])
         return
      else {
         swap heapArray[nodeIndex] and heapArray[parentIndex]
         nodeIndex = parentIndex
      }
   }
}





MaxHeapPercolateDown(nodeIndex, heapArray, arraySize) {
   childIndex = 2 * nodeIndex + 1
   value = heapArray[nodeIndex]

   while (childIndex < arraySize) {
      // Find the max among the node and all the node's children
      maxValue = value
      maxIndex = -1
      for (i = 0; i < 2 && i + childIndex < arraySize; i++) {
         if (heapArray[i + childIndex] > maxValue) {
            maxValue = heapArray[i + childIndex]
            maxIndex = i + childIndex
         }
      }

      if (maxValue == value) {
         return
      }
      else {
         swap heapArray[nodeIndex] and heapArray[maxIndex]
         nodeIndex = maxIndex
         childIndex = 2 * nodeIndex + 1
      }
   }
}


